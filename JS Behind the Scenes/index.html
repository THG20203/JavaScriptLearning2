<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Your Page Title</title>
    <link rel="stylesheet" href="stylebehindscenes.css" />
  </head>
  <body>
    <!-- Your HTML content goes here -->
    <h1>JS Behind the Scenes</h1>
    <h2>High level overview JS</h2>
    <p>
      JavaScript = high level, object orientated, multi paradigm programming
      language.
    </p>
    <p>
      But also - protoype based, interpreted/ just-in-time compiled, dynamic,
      single-threaded, garbage collected programming languages, with first-class
      functions and non-blocking event loop concurrency model.
    </p>
    <ul>
      <li>
        <strong>High-level</strong> - don't have to manage resources -
        everything happens automatically.
      </li>
      <li><strong>Garbage-collected</strong> - cleaning memory for us</li>
      <li>
        <strong>Interpreted or just-in-time compiled</strong> - computers
        processor only understands 0's, 1's. JavaScript is humen readable -
        abstraction of machine code - that step is compiling / interpreting in
        JavaScript engine.
      </li>
      <li>
        <strong>Multi paradigm</strong> - paradigm is an approach / mindset of
        structuring code. JavaScript multi paradigm (flexible) - procedural,
        object orientated, functional programming. imperitive / declarative.
      </li>
      <li>
        <strong>Prototype-based object-orientated</strong> - JavaScript ->
        almost everything is an object, except primitive values like numbers,
        strings. arrays for example are just objects. Protoype inheritence.
        Create arrays from array blueprint (template), called a prototype. This
        contains all the array methods. The arrays that we create in our code
        then inherit the methods from the blue print (so we can use them on the
        arrays).
      </li>
      <li>
        <strong>First-class functions</strong> - means functions = variables.
        Can pass them into other functions, return functions from functions.
      </li>
      <li>
        <strong>Dynamic</strong> - no data type definitions. Types becomes known
        at runtime. Data type of varialbe is automatically changed. let x =
        23;<br />
        x= "Jonas";
      </li>
      <li>
        <strong>Single-threaded</strong> - Concuerrancy model = how JavaScript
        handles multiple tasks happening at the same time. Why do we need that?
        JavaScript runs in one single threat, so it can only do one thing at a
        time. Thread = set of instructions executed in CPU.
      </li>
      <li>
        <strong>Non-blocking event loop</strong> - What about a long running
        task? Sounds like it would block the single thread. But, we want non
        blocking behavior. How do we achieve that? Event loop - event loop:
        takes long running tasks, executes them in the background, puts them
        back in main thread once they are finished.
      </li>
    </ul>
    <h2>JavaScript engine and runtime</h2>
    <p>JS Engine - executes JavaScript code</p>
    <p>Any JS Engine has call stack and heap</p>
    <ul>
      <li>Execution Context = Where code is executed</li>
      <li>
        Heap = unstructured memory pool which stores all objects our application
        needs.
      </li>
    </ul>
    <p>Compilation vs. interpretation</p>
    <p>
      Compilation: Entire code is converted into machine code at once, and
      written to a binary file that can be executed by a computer.
    </p>
    <p>
      Interpretation: Interpreter runs through the source code and executes it
      line by line. Code still needs to be converted to machine code before
      executed.
    </p>
    <p>
      Just-in-time (JIT) compilation: Entire code is converted into machine code
      at once, then executed immediately.
    </p>
    <p>
      Parsing code (read code) -> Parsing process - code is parsed into a data
      structure called AST. Optimisation is happening too.
    </p>
    <p>
      JavaScript runtime - container including all the things that we need to
      use JavaScript (in this case the browser). Core part of runtime is JS
      Engine. Also need Web API's (DOM, console.log etc). JavaScript gets access
      to Web Api's (THAT AREN'T PART OF JS) through the global window object.
      Callback queue - data structure - contains all callback functions ready to
      be excuted. Event Loop - essential for non-blocking concurrency model.
    </p>
    <h2>Execution Context</h2>
    <p>
      Environment in which piece of JavScript is executed. Stores all the
      necessary information for some codes to be executed. Exactly one global
      execution context (EC): Default context, created code that is not inside
      any function (top level).
    </p>
    <p>
      One execution context per function - for each function call. For each
      function call, new execution context is created.
    </p>
    <p>Inside execution context?</p>

    <ul>
      <li>
        Variable environment - let, const, var declations, functions, argument
        object - (this arguments object contains all the arguments that were
        passed into the object that the current execution context belongs to).
      </li>
      <li>Scope Chain</li>
      <li>This Keyword</li>
    </ul>
    <p>
      Arrow functions don't get arguments object and this keyword. Instead they
      can use arguments object and this keyword from their closest function
      parent.
    </p>
    <p>
      Call stack - place where execution contexts get stacked on top of each
      other (keep track of where we are in execution). Changes when things get
      called, moves down.
    </p>
    <p>Scoping: How our program's variables are organised and accessed.</p>
    <p>
      Lexcial scoping - scoping = controlled by placement of functions and
      blocks in the code.
    </p>
    <p>
      Scope = environment in which certain variable is declared (Variable
      environment in the case of functions). Theres globa scope, function scope
      and block scope.
    </p>
    <p>
      Scope of a variable = entire region of code where a certain variable can
      be accessed.
    </p>
    <ul>
      <li>
        Global scope - outside of any function / block. Variables declared in
        global scope - accessible everywhere.
      </li>
      <li>
        Function scope = only accessible inside function, not outside. also
        called local scope.
      </li>
      <li>
        Block scope (ES6) Variables are accessible only inside block (block
        scoped). However, this only applies to let and const. Functions are also
        block scope (only in strict mode).
      </li>
    </ul>
    <p>
      Scope chain look up in the chain scope. Variable look up but NOT down.
    </p>
    <p>Scope Chain vs Call Stack</p>
    <p>
      Scope chain has nothing to do with order in which functions are called.
      Its the order functions are written into the code.
    </p>
    <h2>HOISTING</h2>
    <p>Variable Environment: How are variables created in JavaScript?</p>
    <p>
      <strong>Hoisting</strong> - Makes some types of variables accessible/
      usable in the code before they are actually declared. "Variables lifted to
      the top of their scope."
    </p>
    <p>
      Before execution, code is scanned for variable declarations, and for each
      variable, a new property is created in the variable environment object.
    </p>
    <p>
      Temporal dead zone - region of scope variable is defined but doesn't
      porperly exist.
    </p>
    <script src="scriptbehindscenes.js"></script>
  </body>
</html>
